open Expression
open Types

let mk_val (i : int) : int t = Val (Int i)
let mk_neg (e : int t) : int t = Unop (Int I.Neg, e)
let mk_add (e1 : int t) (e2 : int t) : int t = Binop (Int I.Add, e1, e2)
let mk_sub (e1 : int t) (e2 : int t) : int t = Binop (Int I.Sub, e1, e2)
let mk_mul (e1 : int t) (e2 : int t) : int t = Binop (Int I.Mul, e1, e2)
let mk_div (e1 : int t) (e2 : int t) : int t = Binop (Int I.Div, e1, e2)
let mk_rem (e1 : int t) (e2 : int t) : int t = Binop (Int I.Rem, e1, e2)
let mk_shl (e1 : int t) (e2 : int t) : int t = Binop (Int I.Shl, e1, e2)
let mk_shr_a (e1 : int t) (e2 : int t) : int t = Binop (Int I.ShrA, e1, e2)
let mk_shr_l (e1 : int t) (e2 : int t) : int t = Binop (Int I.ShrL, e1, e2)
let mk_and (e1 : int t) (e2 : int t) : int t = Binop (Int I.And, e1, e2)
let mk_or (e1 : int t) (e2 : int t) : int t = Binop (Int I.Or, e1, e2)
let mk_xor (e1 : int t) (e2 : int t) : int t = Binop (Int I.Xor, e1, e2)
let mk_pow (e1 : int t) (e2 : int t) : int t = Binop (Int I.Pow, e1, e2)
let mk_eq (e1 : int t) (e2 : int t) : bool t = Relop (Int I.Eq, e1, e2)
let mk_ne (e1 : int t) (e2 : int t) : bool t = Relop (Int I.Ne, e1, e2)
let mk_lt (e1 : int t) (e2 : int t) : bool t = Relop (Int I.Lt, e1, e2)
let mk_le (e1 : int t) (e2 : int t) : bool t = Relop (Int I.Le, e1, e2)
let mk_gt (e1 : int t) (e2 : int t) : bool t = Relop (Int I.Gt, e1, e2)
let mk_ge (e1 : int t) (e2 : int t) : bool t = Relop (Int I.Ge, e1, e2)
let mk_to_string (e : int t) : int t = Cvtop (Int I.ToString, e)
let mk_of_string (e : int t) : int t = Cvtop (Int I.OfString, e)
let mk_of_real (e : int t) : int t = Cvtop (Int I.ReinterpretReal, e)
